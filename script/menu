#!/bin/bash

# Colors
RESET='\033[0m'
BLACK='\033[30m'
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[34m'
MAGENTA='\033[35m'
CYAN='\033[36m'
WHITE='\033[37m'

# Menu Colors:
A='\033[1;37m'
B='\033[0;37m'
C='\033[0;91m'
D='\033[0;32m'
E='\033[0;33m'
O='\033[0;31m'
X=''

# Location of temp files
TMP_ALIAS_FILE="/tmp/.ugwentzi_aliases.tmp"
TMP_VIMRC_FILE="/tmp/.ugwentzi_vimrc.tmp"

# Clean if exit is triggered or if terminal is closed
trap cleanup EXIT SIGHUP

# Trap interrupt code (^C ^Z)
trap '' SIGINT SIGTSTP

# Disable Ctrl+Z
stty susp ''

# Disable text printing
stty -echo

# Disable the cursor
tput civis

#============================ COMMON FUNCTIONS ================================#
# Cleanup function to delete the script
# And re-enable text printing and cursor
cleanup() {
	stty echo
	tput cnorm
	stty susp '^Z'
	setxkbmap -option
	[ -f "$TMP_ALIAS_FILE" ] && rm -f "$TMP_ALIAS_FILE"
	rm -- "$0"
	clear
	printf "\n"
	printf "  $O┌$X──────────────────────────────$X┐$RESET\n"
	printf "  $O│$D Cleaned everything. Goodbye! $O│$RESET\n"
	printf "  $O└$X──────────────────────────────$X┘$RESET\n"
	printf "\n"
}

invalid_option() {
	printf "\n${RED}Invalid option '$choice'. Please try again.${RESET}\n"
	sleep 1
}

exit_script() {
	exit 0
}

download_file() {
	local url=$1
	local description=$2

	printf "\nDownloading %s...\n" "$description"
	curl -O "$url"
	if [ $? -eq 0 ]; then
		printf "\n${GREEN}%s Downloaded!${RESET}\n" "$description"
		printf "Press Enter to continue..."
		read -r
	else
		printf "\n${RED}Failed to download %s.${RESET}\n" "$description"
		sleep 3
	fi
}
#==============================================================================#

#=========================== CORRECTION SUBMENU ===============================#
set_environment() {

	local RED='\033[38;2;255;0;0m'
    local MAGENTA='\033[38;2;255;0;255m'
    local PURPLE='\033[38;2;102;0;255m'
    local WHITE='\033[38;2;255;255;255m'

	# remap CapsLock to Escape
	setxkbmap -option caps:escape

	# Create a temporary alias file
	cat <<- EOF > $TMP_ALIAS_FILE
		EDITOR=vim
		PS1='\[$RED\]\u@\h\[$MAGENTA\]:\[$PURPLE\]\w\[$MAGENTA\]\$\[$WHITE\] '
		mkcd_() { mkdir "$1" && cd "$1"; }
		alias mkcd='mkcd_'
		alias ls='ls --color=auto'
		alias grep='grep --color=auto'
		alias sk='setxkbmap -option caps:escape'
		alias ks='setxkbmap -option caps:capslock'
		alias gl='git pull'
		alias gp='git push'
		alias gcl='git clone'
		alias gst='git status'
		alias cca='gcc *.c -Wall -Wextra -Werror && ./a.out'
		alias ccf='gcc *.c -Wall -Wextra -Werror'
		alias vim='vim -u $TMP_VIMRC_FILE'
		alias endcorr='setxkbmap -option && rm -f $TMP_ALIAS_FILE && exit'
	EOF

	cat <<- 'EOF' > "$TEMP_VIMRC_FILE"
		autocmd VimEnter * normal! '"
		syntax on
		colorscheme shine
		filetype indent on
		set tabstop=4
		set shiftwidth=4
		set is hls
	EOF

	# open terminator
	terminator --geometry=1920x2160+0+0 \
		-e "bash --init-file $TMP_ALIAS_FILE" 2>/dev/null &
}

submenu_correction() {
    while true; do
        clear
        printf "\n"
        printf "  $O┌─$X────────────────────────────$X─┐$RESET\n"
        printf "  $O│ $A      Correction Menu       $O │$RESET\n"
        printf "  $O├─$X────────────────────────────$X─┤$RESET\n"
        printf "  $O│ $B 1. Get Mains               $O │$RESET\n"
        printf "  $O│ $B 2. Set environment         $O │$RESET\n"
        printf "  $O│ $E 3. Go Back              (b)$O │$RESET\n"
        printf "  $O│ $C 4. Exit                 (q)$O │$RESET\n"
        printf "  $O└─$X────────────────────────────$X─┘$RESET\n"

        # Read user's option choice
        read -n 1 -r choice
        tput cub 1
        printf " "
        tput cub 1

        # Execute based on choice
        case $choice in
            1) submenu_mains ;;
            2) set_environment ;;
          b|3) break ;;
          q|4) exit_script ;;
            *) invalid_option ;;
        esac
    done
}
#==============================================================================#

#============================== MAINS SUBMENU =================================#
get_url_libft_main() {
	local part1="https://raw.githubusercontent.com/Ugo-42/test_main"
	local part2="/refs/heads/main/libft_main/main.c"
	echo "${part1}${part2}"
}

get_url_ft_printf_main() {
	local part1="https://raw.githubusercontent.com/Ugo-42/test_main/"
	local part2="refs/heads/main/ft_printf_main/main.c"
	echo "${part1}${part2}"
}

get_url_get_next_line_main() {
	local part1="https://raw.githubusercontent.com/Ugo-42/test_main/"
	local part2="refs/heads/main/get_next_line_main/main.c"
	echo "${part1}${part2}"
}
submenu_mains() {
    while true; do
        clear
        printf "\n"
        printf "  $O┌─$X────────────────────────────$X─┐$RESET\n"
        printf "  $O│ $A          My Mains          $O │$RESET\n"
        printf "  $O├─$X────────────────────────────$X─┤$RESET\n"
        printf "  $O│ $B 1. libft                   $O │$RESET\n"
        printf "  $O│ $B 2. ft_printf               $O │$RESET\n"
        printf "  $O│ $B 3. get_next_line           $O │$RESET\n"
        printf "  $O│ $E 4. Go Back              (b)$O │$RESET\n"
        printf "  $O│ $C 5. Exit                 (q)$O │$RESET\n"
        printf "  $O└─$X────────────────────────────$X─┘$RESET\n"

        # Read user's option choice
        read -n 1 -r choice
        tput cub 1
        printf " "
        tput cub 1

        # Execute based on choice
        case $choice in
			1) download_file "$(get_url_libft_main)" "libft main.c" ;;
            2) download_file "$(get_url_ft_printf_main)" "ft_printf main.c" ;;
            3) download_file "$(get_url_get_next_line_main)" "get_next_line main.c" ;;
          b|4) break ;;
          q|5) exit_script ;;
            *) invalid_option ;;
        esac
    done
}
#==============================================================================#

#=============================== MAIN MENU ====================================#
while true; do
    clear
    printf "\n"
    printf "  $O┌─$X────────────────────────────$X─┐$RESET\n"
    printf "  $O│ $A        Main Menu           $O │$RESET\n"
    printf "  $O├─$X────────────────────────────$X─┤$RESET\n"
    printf "  $O│ $B 1. Correction              $O │$RESET\n"
    printf "  $O│ $C 2. Exit                 (q)$O │$RESET\n"
    printf "  $O└─$X────────────────────────────$X─┘$RESET\n"

    # Read user's option choice
    read -n 1 -r choice
    tput cub 1
    printf " "
    tput cub 1

    # Execute based on choice
    case $choice in
        1) submenu_correction ;;  # Call the submenu
      q|2) exit_script ;;
        *) invalid_option ;;
    esac
done
#==============================================================================#
